```SmalltalkObject subclass: #Pong	instanceVariableNames: 'ball players view walls width height time labelElement'	classVariableNames: ''	package: 'Pong'``````SmalltalkPong>>ball	^ ball``````SmalltalkPong>>ball: aBall	ball := aBall.	ball game: self.	self resetBall``````SmalltalkPong>>beat	time := time + 1.	players do: #beat.	ball beat``````SmalltalkPong>>beginingSide	players ifNotNil: [ 		(players collect: #score) sum odd ifTrue: [ ^ #firstPlayer ]	].	^ #secondPlayer	``````SmalltalkPong>>gameDescription	^ 'Time = ', time asString, '   Score top = ', players first score asString, '   Score below = ', players second score asString``````SmalltalkPong>>height	^ height``````SmalltalkPong>>initialize	super initialize.	self players: { PAIPlayer new . PAIPlayer new }.	self ball: PBall new.	width := 400.	height := 200.	time := 0``````SmalltalkPong>>initializeView	| playerElements |	view := RTView new.	walls := RTBox new		width: 10;		height: height;		elementsOn: #(1 2).		labelElement := (RTLabel new elementOn: time)		setAsFixed;		yourself.		labelElement translateBy: 150 @ 30.	view add: labelElement.		view addAll: walls.	walls first translateTo: width / -2 @ 0.	walls second translateTo: width / 2 @ 0.	playerElements := players		collect: [ :p | p initializeElementWith: view ].	playerElements first translateTo: 0 @ (height / -2).	playerElements second translateTo: 0 @ (height / 2).	view add: (ball initializeElementWith: view)``````SmalltalkPong>>open	| animation |	self initializeView.	animation := RTActiveAnimation new		intervalInMilliseconds: 10;		blockToExecute: [ self beat.			labelElement trachelShape text: self gameDescription ].	view addAnimation: animation.	view open``````SmalltalkPong>>player1Score	players first increaseScore.	self resetBall.``````SmalltalkPong>>player2Score	players second increaseScore.	self resetBall.``````SmalltalkPong>>players	^ players``````SmalltalkPong>>players: somePlayers	players := somePlayers.	players first name: '1'.	players second name: '2'.	players do: [ :p | p game: self ]``````SmalltalkPong>>resetBall		| newX spY spX |	self beginingSide == #firstPlayer 		ifTrue: [ 			newX := players first myX.			spY := -2 ]		ifFalse: [ 			newX := players second myX.			spY := 2 ].	spX := newX > 0 ifTrue: [ -3 ] ifFalse: [ 3 ].	ball speed: spX @ spY.	ball element translateTo: newX @ 0.	ball reset.``````SmalltalkPong>>view	^ view``````SmalltalkPong>>walls	^ walls``````SmalltalkPong>>width	^ width``````SmalltalkObject subclass: #PBall	instanceVariableNames: 'position speed element game'	classVariableNames: ''	package: 'Pong'``````SmalltalkPBall>>beat	self incrementalMove.	self element position y < (game players first element position y - (game players first element height / 2))		ifTrue: [ game player2Score ].	self element position y > (game players second element position y + (game players second element height / 2))		ifTrue: [ game player1Score ]``````SmalltalkPBall>>bumpPlayer	speed := speed x @ speed y negated``````SmalltalkPBall>>bumpWall	speed := speed x negated @ speed y``````SmalltalkPBall>>createElement	^ RTEllipse new		size: 10;		color: Color red;		elementOn: self.``````SmalltalkPBall>>element	element ifNil: [ element := self createElement ].	^ element``````SmalltalkPBall>>game	^ game``````SmalltalkPBall>>game: anObject	game := anObject``````SmalltalkPBall>>incrementalMove	self moveBy: speed``````SmalltalkPBall>>initialize	super initialize.	``````SmalltalkPBall>>initializeElementWith: aView"	| collision |	collision := RTCollision new		elementToCheckForCollision: aView elements copy.	collision		callback: [ :aShape :side | 			(side == #top or: [ side == #bottom ])				ifTrue: [ self bumpPlayer: aShape ]				ifFalse: [ self bumpWall ] ].	self element @ collision."	aView add: self element.	^ self element``````SmalltalkPBall>>moveBy: aDelta	| isTouchingWall isTouchingPlayer |	self element translateBy: aDelta.		"We check for collisions."	"The walls"	isTouchingWall := game walls anySatisfy: [ :w |		 w encompassingRectangle containsPoint: self element position ].		"Then the players"	isTouchingPlayer := game players anySatisfy: [ :p |		p element encompassingRectangle containsPoint: self element position ].		isTouchingWall ifTrue: [ 		self bumpWall. self element translateBy: aDelta negated ].	isTouchingPlayer ifTrue: [ 		self bumpPlayer. 		"We move away from the player, just to avoid oddities"		self translateBy: aDelta x @ aDelta y negated ]``````SmalltalkPBall>>myX	^ self element position x``````SmalltalkPBall>>reset``````SmalltalkPBall>>speed	^ speed``````SmalltalkPBall>>speed: speedAsPoint	speed := speedAsPoint``````SmalltalkPBall>>translateBy: aDeltaAsPoint	"Move the ball by a given delta, as a point"	self element translateBy: aDeltaAsPoint``````SmalltalkPBall subclass: #PFastBall	instanceVariableNames: 'isFast'	classVariableNames: ''	package: 'Pong'``````SmalltalkPFastBall>>bumpPlayer	| closePlayer |	super bumpPlayer.	closePlayer := self playerCloseToTheBall.	"We check if we are close to the borders of the player"	((self myX		- closePlayer element encompassingRectangle left) abs < 10		or: [ (self myX				- closePlayer element encompassingRectangle right) abs < 10 ])		ifTrue: [ self setAsFast ]		ifFalse: [ self setAsSlow ]``````SmalltalkPFastBall>>incrementalMove	isFast 		ifTrue: [ self moveBy: speed * 2 ]		ifFalse: [ self moveBy: speed ]``````SmalltalkPFastBall>>initialize	super initialize.	isFast := false``````SmalltalkPFastBall>>playerCloseToTheBall	^ self element position y < 0		ifTrue: [ game players first ]		ifFalse: [ game players second ]``````SmalltalkPFastBall>>reset	self setAsSlow``````SmalltalkPFastBall>>setAsFast	isFast := true``````SmalltalkPFastBall>>setAsSlow	isFast := false``````SmalltalkPAbstractPlayer subclass: #PSmartPlayer	instanceVariableNames: ''	classVariableNames: ''	package: 'Pong'``````SmalltalkPSmartPlayer>>beat	self element position x <  self ballX ifTrue: [ self right ].	self element position x > self ballX ifTrue: [ self left ].``````SmalltalkPAbstractPlayer subclass: #PHumanPlayer	instanceVariableNames: ''	classVariableNames: ''	package: 'Pong'``````SmalltalkPHumanPlayer>>initializeElementWith: aView	element := super initializeElementWith: aView.	aView when: TRMouseMove do: [ :evt |		| p |		p := element position.		element translateTo: evt position x @ p y.		aView signalUpdate ].	^ element``````SmalltalkPAbstractPlayer subclass: #PAIPlayer	instanceVariableNames: 'network'	classVariableNames: ''	package: 'Pong'``````SmalltalkPAIPlayer>>beat	| input result |	input := OrderedCollection new.	input add: ((self myX + (game width / 2)) / (game width)) asFloat.	input add: ((self ballX + (game width / 2)) / (game width)) asFloat.	input add: ((self ballY + (game height / 2)) / (game height)) asFloat.	input add: ((self ballSpeedX + 6) / 12).	input add: ((self ballSpeedY + 4) / 8).		input := input collect: [ :v | (v max: 0) min: 1 ].		"( input allSatisfy: [ :v | v >=0 and: [ v <= 1 ] ] ) ifFalse: [ self halt ].	self assert: [ input allSatisfy: [ :v | v >=0 and: [ v <= 1 ] ] ]."		result := network predict: input.	result = 1 ifTrue: [ self left ].	result = 2 ifTrue: [ self right ].``````SmalltalkPAIPlayer>>initialize	super initialize.	network := NNetwork new.	network configure: 5 hidden: 5 nbOfOutputs: 3.``````SmalltalkPAIPlayer>>network: aNetwork	network := aNetwork ``````SmalltalkPAbstractPlayer subclass: #PWallPlayer	instanceVariableNames: ''	classVariableNames: ''	package: 'Pong'``````SmalltalkPWallPlayer>>game: aGame	super game: aGame.	self width: aGame width``````SmalltalkPWallPlayer>>initialize	super initialize.	width := 200``````SmalltalkPAbstractPlayer subclass: #PAgressiveAIPlayer	instanceVariableNames: 'network'	classVariableNames: ''	package: 'Pong'``````SmalltalkPAgressiveAIPlayer>>beat	| input result factor |	factor := (self position y > 0) ifTrue: [ 1 ] ifFalse: [ -1 ].	input := OrderedCollection new.	input add: (self myX + (game width / 2)) / game width.	input add: (self ballX + (game width / 2)) / game width.	input add: (self ballY * factor + (game height / 2)) / game height.	input add: (self ballSpeedX + 3) / 6.	input add: (self ballSpeedY * factor + 2) / 4.	input add: (self opponentX + (game width / 2)) / game width.	"The ballY can be slightly outside the field"	input := input collect: [ :vv | (vv max: 0) min: 1 ].	result := network predict: input.		result = 1 ifTrue: [ self left ].	result = 2 ifTrue: [ self right ].``````SmalltalkPAgressiveAIPlayer>>initialize	super initialize.	network := NNetwork new.	network configure: 6 hidden: 5 nbOfOutputs: 3.``````SmalltalkPAgressiveAIPlayer>>network: aNetwork	network := aNetwork ``````SmalltalkPAgressiveAIPlayer>>opponentX	| p |	p := game players first == self 		ifTrue: [ game players second ]		ifFalse: [ game players first ].	^ p element position x``````SmalltalkObject subclass: #PAbstractPlayer	instanceVariableNames: 'game name score element width'	classVariableNames: ''	package: 'Pong'``````SmalltalkPAbstractPlayer>>ballSpeedX	^ game ball speed x``````SmalltalkPAbstractPlayer>>ballSpeedY	^ game ball speed y``````SmalltalkPAbstractPlayer>>ballX	^ game ball element position x``````SmalltalkPAbstractPlayer>>ballY	^ game ball element position y``````SmalltalkPAbstractPlayer>>beat``````SmalltalkPAbstractPlayer>>createElement	^ RTBox new width: width; height: 10; elementOn: self``````SmalltalkPAbstractPlayer>>element	element ifNil: [ element := self createElement ].	^ element``````SmalltalkPAbstractPlayer>>game	^ game``````SmalltalkPAbstractPlayer>>game: anObject	game := anObject``````SmalltalkPAbstractPlayer>>increaseScore	score := score + 1``````SmalltalkPAbstractPlayer>>initialize	super initialize.	score := 0.	width := 40``````SmalltalkPAbstractPlayer>>initializeElementWith: aView	aView add: self element.	^ self element``````SmalltalkPAbstractPlayer>>left	self myX <= ((game width - width)/ -2) ifTrue: [ ^ self ].	self element translateBy: -3 @ 0``````SmalltalkPAbstractPlayer>>myX	^ self element position x``````SmalltalkPAbstractPlayer>>myX: aValue	self element translateTo: aValue @ self position y``````SmalltalkPAbstractPlayer>>name	^ name``````SmalltalkPAbstractPlayer>>name: anObject	name := anObject``````SmalltalkPAbstractPlayer>>play``````SmalltalkPAbstractPlayer>>position	^ self element position``````SmalltalkPAbstractPlayer>>printOn: str	str nextPutAll: '<Player '.	name ifNotNil: [ str nextPutAll: name ].	str nextPut: $>``````SmalltalkPAbstractPlayer>>right	self myX >= ((game width - width) / 2) ifTrue: [ ^ self ].	element translateBy: 3 @ 0``````SmalltalkPAbstractPlayer>>score	^ score``````SmalltalkPAbstractPlayer>>width	^ width``````SmalltalkPAbstractPlayer>>width: anObject	width := anObject``````SmalltalkTestCase subclass: #PongTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Pong'``````SmalltalkPongTest>>testBasic	| p |	p := Pong new.	p ball: PFastBall new.	p players: { PAgressiveAIPlayer new   . PAIPlayer new }.	p initializeView.	1500 timesRepeat: [ p beat ]```