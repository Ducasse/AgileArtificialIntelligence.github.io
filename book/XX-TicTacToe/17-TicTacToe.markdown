<!--		| c |	c := CodeToMarkdown new.	c addClass: TTTAbstractPlayer.	c addClass: TTTRandomPlayer.	c addClass: TicTacToe.	c addClass: TicTacToeTest.	c addClass: TTTHumanPlayer.	c addClass: TTTAIPlayer.	c writeMarkdown: '/Users/alexandrebergel/Dropbox/Workspace/Books/AgileArtificialIntelligence.github.io/book/17-TicTacToe/17-TicTacToe.markdown'-->```SmalltalkObject subclass: #TTTAbstractPlayer	instanceVariableNames: 'name game'	classVariableNames: ''	package: 'TicTacToe'``````SmalltalkTTTAbstractPlayer>>game	^ game``````SmalltalkTTTAbstractPlayer>>game: anObject	game := anObject``````SmalltalkTTTAbstractPlayer>>getPositionToPlay 	^ self subclassResponsibility``````SmalltalkTTTAbstractPlayer>>name	^ name``````SmalltalkTTTAbstractPlayer>>name: anObject	name := anObject``````SmalltalkTTTAbstractPlayer>>play	game atIndex: self getPositionToPlay put: self name``````SmalltalkTTTAbstractPlayer>>printOn: str	str nextPutAll: '<Player '.	name ifNotNil: [ str nextPut: name ].	str nextPut: $>``````SmalltalkTTTAbstractPlayer subclass: #TTTRandomPlayer	instanceVariableNames: ''	classVariableNames: ''	package: 'TicTacToe'``````SmalltalkTTTRandomPlayer>>getPositionToPlay	^ game freeCells atRandom``````SmalltalkObject subclass: #TicTacToe	instanceVariableNames: 'table players playerIndex winner'	classVariableNames: ''	package: 'TicTacToe'``````SmalltalkTicTacToe>>at: aPoint	^ table at: (self fromPointToIndex: aPoint)``````SmalltalkTicTacToe>>at: aPoint put: aChar	self atIndex: (self fromPointToIndex: aPoint) put: aChar``````SmalltalkTicTacToe>>atIndex: anIndex	^ table at: anIndex``````SmalltalkTicTacToe>>atIndex: anIndex put: aChar	self assert: [ (table at: anIndex) = $  ] description: 'Cannot play'.	table at: anIndex put: aChar``````SmalltalkTicTacToe>>checkIfWinner	| possibilities winderName |	possibilities := 	{ #(1 2 3) . #(4 5 6) . #(7 8 9) .	  #(1 5 9) . #(3 5 7) .	  #(1 4 7) . #(2 5 8) . #(3 6 9) }.	possibilities do: [ :pos | 		(self atIndex: pos first) ~= $ ifTrue: [ 			(((self atIndex: pos first) = (self atIndex: pos second)) 				and: [ (self atIndex: pos first) = (self atIndex: pos third) ])				ifTrue: [ 						winderName := self atIndex: pos first. 						^ self setWinderFromName: winderName ] ] ]``````SmalltalkTicTacToe>>currentPlayer	^ players at: playerIndex``````SmalltalkTicTacToe>>currentPlayerName	^ (players at: playerIndex) name``````SmalltalkTicTacToe>>freeCells	"Return the list of indexes in the table that are not occupied"	| result |	result := OrderedCollection new.	table withIndexDo: [ :v :index | 		v = $  ifTrue: [ result add: index ] ].	^ result``````SmalltalkTicTacToe>>fromIndexToPoint: anIndex	^ (((anIndex - 1) // 3) + 1) @ ((anIndex - 1) \\ 3 + 1)``````SmalltalkTicTacToe>>fromPointToIndex: aPoint	^ (aPoint x - 1) * 3 + (aPoint y - 1) + 1``````SmalltalkTicTacToe>>hasWinner	^ winner notNil``````SmalltalkTicTacToe>>initialize	super initialize.	table := Array new: 9 withAll: $ . ``````SmalltalkTicTacToe>>isGameEnded	^ self freeCells isEmpty or: [ winner notNil ]``````SmalltalkTicTacToe>>players	^ players ``````SmalltalkTicTacToe>>players: somePlayers	self assert: [ somePlayers isCollection ] description: 'Should provide a collection of players'.	self assert: [ somePlayers size = 2 ] description: 'Two players are required'.	self assert: [ somePlayers asSet size = 2 ] description: 'Two different player should be provided'.	players := somePlayers asArray.	somePlayers first name: $X.	somePlayers second name: $O.	playerIndex := 1.	somePlayers do: [ :p | p game: self ]``````SmalltalkTicTacToe>>printOn: str	str cr.	str nextPutAll: ($| join: (table copyFrom: 1 to: 3)); cr. 	str nextPutAll: '-----'; cr.	str nextPutAll: ($| join: (table copyFrom: 4 to: 6)); cr.	str nextPutAll: '-----'; cr.	str nextPutAll: ($| join: (table copyFrom: 7 to: 9)); cr.	self isGameEnded 		ifTrue: [ 			self hasWinner 				ifTrue: [ 					str nextPutAll: 'Player '.					str nextPut: winner name.					str nextPutAll: ' won' ]				ifFalse: [ 					str nextPutAll: 'Game over' ]			]		ifFalse: [ 			str nextPutAll: 'Player '.			str nextPut: (self currentPlayerName).			str nextPutAll: ' to play' ].	str cr	``````SmalltalkTicTacToe>>setWinderFromName: aName	winner := players detect: [ :p | p name = aName ]``````SmalltalkTicTacToe>>swapPlayer	playerIndex := (playerIndex = 1) ifTrue: [ 2 ] ifFalse: [ 1 ]``````SmalltalkTicTacToe>>table 	^ table``````SmalltalkTicTacToe>>update	self isGameEnded ifTrue: [ ^ self ].	self currentPlayer play.	self checkIfWinner.	self swapPlayer``````SmalltalkTicTacToe>>winner	^ winner``````SmalltalkTestCase subclass: #TicTacToeTest	instanceVariableNames: 'game'	classVariableNames: ''	package: 'TicTacToe'``````SmalltalkTicTacToeTest>>setUp	game := TicTacToe new``````SmalltalkTicTacToeTest>>testConvertionIndexToPoint	self assert: (game fromIndexToPoint: 1) equals: 1 @ 1.	self assert: (game fromIndexToPoint: 3) equals: 1 @ 3.	self assert: (game fromIndexToPoint: 7) equals: 3 @ 1.	self assert: (game fromIndexToPoint: 9) equals: 3 @ 3.``````SmalltalkTicTacToeTest>>testConvertionPointToIndex	self assert: (game fromPointToIndex: 1 @ 1) equals: 1.	self assert: (game fromPointToIndex: 1 @ 3) equals: 3.	self assert: (game fromPointToIndex: 3 @ 1) equals: 7.	self assert: (game fromPointToIndex: 3 @ 3) equals: 9.	``````SmalltalkTicTacToeTest>>testFreeCells	self assert: game freeCells size equals: 9.	self assert: (game freeCells includes: 3).	game at: 1 @ 3 put: $X.	self assert: game freeCells size equals: 8.	self deny: (game freeCells includes: 3).``````SmalltalkTicTacToeTest>>testGame	game players: { TTTRandomPlayer new . TTTRandomPlayer new }.	game update.	10 timesRepeat: [ game update ]``````SmalltalkTTTAbstractPlayer subclass: #TTTHumanPlayer	instanceVariableNames: ''	classVariableNames: ''	package: 'TicTacToe'``````SmalltalkTTTHumanPlayer>>getPositionToPlay 	^ UIManager default chooseFrom: (1 to: 9)``````SmalltalkTTTAbstractPlayer subclass: #TTTAIPlayer	instanceVariableNames: 'network'	classVariableNames: ''	package: 'TicTacToe'``````SmalltalkTTTAIPlayer>>getPositionToPlay  	| input |	input := OrderedCollection new.	game table do: [ :v |		v = $  ifTrue: [ input addAll: #(0 0 1) ].		v = $X ifTrue: [ input addAll: #(0 1 0) ].		v = $O ifTrue: [ input addAll: #(1 0 0) ].		 ].	^ (network predict: input) + 1	``````SmalltalkTTTAIPlayer>>network: aNetwork	network := aNetwork ```~~~~~~~~n := NNetwork new.n configure: 9 * 3 hidden: 6 nbOfOutputs: 9.g := GAEngine new.g populationSize: 500.g mutationRate: 0.1.g selection: (GATournamentSelection new).g endForMaxNumberOfGeneration: 50.g crossoverOperator: (GAConstrainedCrossoverOperation new possibleCutpoints: n getPossibleCutpoints).g mutationOperator: 	(GAMutationOperation new).g numberOfGenes: n numberOfValues.g createGeneBlock: [ :rand :index :ind | rand next * 10 - 5 ].g fitnessBlock: [ :genes | 	| score game |	score := 0.	n setWeightsAndBias: genes.	10 timesRepeat: [		game := TicTacToe new.		game players: { TTTAIPlayer new network: n . TTTRandomPlayer new }.		9 timesRepeat: [ [ game update ] on: AssertionFailure do: [ score := score - 1 ] ].		(game hasWinner and: [ game winner == game players first ])			ifTrue: [ score := score + 1 ]. ].	score	].g run.g.n setWeightsAndBias: g result.game := TicTacToe new.game players: { TTTAIPlayer new network: n . TTTHumanPlayer new }.game update~~~~~~~~~~~~~~~~n2 := n.n := NNetwork new.n configure: 9 * 2 hidden: 15 hidden: 15 nbOfOutputs: 9.g := GAEngine new.g populationSize: 400.g mutationOperator: (GASwapMutationOperation new).g mutationRate: 0.05.g selection: (GATournamentSelection new).g endForMaxNumberOfGeneration: 50.g crossoverOperator: (GAConstrainedCrossoverOperation new possibleCutpoints: n getPossibleCutpoints).g numberOfGenes: n numberOfValues.g createGeneBlock: [ :rand :index :ind | rand next * 10 - 5 ].g fitnessBlock: [ :genes | 	| score game |	score := 0.	n setWeightsAndBias: genes."	30 timesRepeat: [		game := TicTacToe new.		game players: { TTTAIPlayer new network: n . TTTAIPlayer new network: n2 }.		t := 9.		9 timesRepeat: [ game update. game hasWinner ifFalse: [ t := t - 1 ] ].		(game hasWinner and: [ game winner == game players first ])			ifTrue: [ score := score + t ]. ]."	200 timesRepeat: [		game := TicTacToe new.		game players: { TTTAIPlayer new network: n . TTTRandomPlayer new }.		t := 9.		9 timesRepeat: [ game update. game hasWinner ifFalse: [ t := t - 1 ] ].		(game hasWinner and: [ game winner == game players first ])			ifTrue: [ score := score + t ]. ].	score	].g run.g."SMART VS HUMAN"n setWeightsAndBias: g result.game := TicTacToe new.game players: { TTTSmartPlayer new . TTTHumanPlayer new }.game update."AI VS HUMAN"n setWeightsAndBias: g result.game := TicTacToe new.game players: { TTTAIPlayer new network: n  . TTTHumanPlayer new }.game update."AI VS RANDOM"n setWeightsAndBias: g result.score := 0.300 timesRepeat: [ 	game := TicTacToe new.	game players: { TTTAIPlayer new network: n . TTTRandomPlayer new }.	9 timesRepeat: [ game update ].	(game hasWinner and: [ game winner == game players first ])			ifTrue: [ score := score + 1 ]. ].(score / 300) asFloat round: 2."RANDOM VS RANDOM"n setWeightsAndBias: g result.score := 0.300 timesRepeat: [ 	game := TicTacToe new.	game players: { TTTRandomPlayer new . TTTRandomPlayer new }.	9 timesRepeat: [ game update ].	(game hasWinner and: [ game winner == game players first ])			ifTrue: [ score := score + 1 ]. ].(score / 300) asFloat round: 2 ~~~~~~~~ 